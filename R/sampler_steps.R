#' MNIW update step for group-specific VAR parameters
#'
#' @description
#' Performs one update for group parameters
#' in a hierarchical VAR model with Matrix-Normal / Inverse-Wishart
#' priors. Given the global state (\code{A}, \code{Sigma}, \code{V})
#' and hyperparameters in \code{STV}, the function updates the
#' group-specific coefficient matrix \code{A_g} and covariance matrix
#' \code{S_g}.
#'
#' @param Yg Matrix. Group-specific dependent variables (\eqn{T_g \times N}).
#' @param Zg Matrix. Group-specific regressors (\eqn{T_g \times K}): stacked lag matrices.
#' @param STV List of starting values and hyperparameters (from
#' \code{build_starting_values()}), providing \code{nu}.
#' @param State List containing the current global state of the sampler,
#' including \code{A}, \code{V}, \code{Sigma}, and lists \code{Ag}, \code{Sg}.
#' @param g Integer. Index of the group/country to update (position in the \code{Y_list}/\code{Z_list} lists).
#' @return
#' An updated version of \code{State}, where the elements
#' \code{State$Ag[[g]]} and \code{State$Sg[[g]]} are replaced by their
#' newly sampled values.
#'
#' @details
#' The update follows the conditional MNIW structure:
#' \itemize{
#'   \item \code{S_g} is drawn from an inverse-Wishart.
#'   \item \code{A_g | S_g} is then sampled from a matrix-normal distribution
#'   with mean \code{A_post}, row covariance \code{V_post}, and column
#'   covariance \code{S_g}.
#' }
#' All matrices are symmetrized and ridge-stabilized to ensure numerical
#' positive-definiteness.
#'
#' @examples
#' # Dummy example
#' # Yg <- matrix(rnorm(50), 10, 5)
#' # Zg <- matrix(rnorm(100), 10, 10)
#' # STV <- build_starting_values(N = 5, K = 10, lag = 2)
#' # State <- init(STV, list(Yg), list(Zg), hyper(STV))
#' # State <- step_country_MNIW(Yg, Zg, STV, State, g = 1)
#'
#' @export
step_country_MNIW <- function(Yg, Zg, STV, State, g) {

    V     <- State$V
    Sigma <- State$Sigma
    A     <- State$A
    nu    <- STV$nu

    N  <- ncol(Yg)
    YY <- t(Yg) %*% Yg
    ZZ <- t(Zg) %*% Zg
    V  <- (V + t(V))/2

    # V^{-1}
    UV   <- chol(V + diag(1e-8,nrow(V)))
    Vinv <- chol2inv(UV)

    Mmat <- Vinv + ZZ
    Mmat <- (Mmat + t(Mmat))/2

    UM     <- chol(Mmat)
    V_post <- chol2inv(UM)

    A_post  <- V_post %*% (Vinv %*% A + t(Zg) %*% Yg)
    nu_post <- nu + nrow(Yg)

    A_Vinv_A   <- t(A) %*% (Vinv %*% A)
    correction <- t(A_post) %*% (Mmat %*% A_post)

    S_post <- (nu - N - 1) * ((Sigma + t(Sigma))/2) + YY + A_Vinv_A  - correction
    S_post <- (S_post + t(S_post))/2

    # Sigma_g
    USp <- chol(S_post)
    Sg_new <- invwishart_rnd(nu_post, S_post)

    # A_g|S_g
    V_post <- (V_post + t(V_post))/2
    Sg_new <- (Sg_new + t(Sg_new))/2
    Ag_new <- rmatnorm(A_post, V_post, Sg_new)

    State$Ag[[g]] <- Ag_new
    State$Sg[[g]] <- Sg_new
    State
}

#' Global update step for the VAR coefficient matrix A
#'
#' @description
#' Performs the global update of the coefficient matrix \code{A}.
#' Conditional on the group-specific matrices
#' \code{A_g} and \code{S_g}, and on the covariance matrix \code{V},
#' the function computes the posterior parameters of the matrix-normal
#' distribution for \code{A} and draws a new sample accordingly.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, providing \code{M} and \code{S}.
#' @param State List containing the current global state of the sampler
#' (including \code{A}, \code{V}, and the lists \code{Ag}, \code{Sg}).
#' @param Hyper List of scalar hyperparameters generated by \code{hyper()},
#' containing in particular \code{m} and \code{s}.
#'
#' @return
#' The \code{State} list updated with a new draw for \code{A}.
#'
#' @details
#' The update corresponds to the conditional posterior
#' \deqn{A \mid \{A_g, S_g\}, V \sim MN(M_{A,\post},\, V,\, S_{A,\post}^{-1})}
#' derived from a matrix-normal prior and the group-specific deviations.
#' The function computes:
#' \itemize{
#'   \item the precision matrix \code{SA_post},
#'   \item the posterior mean \code{MA_post},
#'   \item and finally samples \code{A} using \code{rmatnorm()}.
#' }
#' All matrices are symmetrized and ridge-stabilized before inversion
#' to ensure numerical consistency.
#'
#' @examples
#' # Minimal reproducible structure (dimensions only)
#' # STV <- build_starting_values(N = 5, K = 10, lag = 2)
#' # Hyper <- hyper(STV)
#' # State <- init(STV, list(matrix(rnorm(50),10,5)),
#' #                     list(matrix(rnorm(100),10,10)), Hyper)
#' # State <- step_A_MN(STV, State, Hyper)
#'
#' @export
step_A_MN <- function(STV, State, Hyper) {
    Ag <- State$Ag
    Sg <- State$Sg
    G  <- length(Ag)
    V  <- State$V

    M    <- STV$M
    Smat <- STV$S

    m <- Hyper$m
    s <- Hyper$s

    Sg_inv_sum    <- matrix(0, nrow(Smat), ncol(Smat))
    inv_Ag_Sg_sum <- matrix(0, nrow(M), ncol(M))

    N <- ncol(Smat)
    I <- diag(1, N)

    V    <- (V + t(V))/2
    Smat <- (Smat + t(Smat))/2

    US    <- chol(Smat)
    S_inv <- chol2inv(US)

    for (i in seq_len(G)) {
        Sg_i   <- (Sg[[i]] + t(Sg[[i]]))/2
        USg    <- chol(Sg_i)
        Sg_inv <- chol2inv(USg)

        inv_Ag_Sg_sum <- inv_Ag_Sg_sum + Ag[[i]] %*% Sg_inv
        Sg_inv_sum    <- Sg_inv_sum + Sg_inv
    }

    SA_post <- (1/s) * S_inv + Sg_inv_sum
    SA_post <- (SA_post + t(SA_post))/2

    USA    <- chol(SA_post)
    SA_inv <- chol2inv(USA)

    MA_post <- ((m/s) * M %*% S_inv + inv_Ag_Sg_sum) %*% SA_inv
    V       <- (V + t(V))/2
    SA_post <- (SA_post + t(SA_post))/2

    A_new   <- rmatnorm(MA_post, V, SA_inv)
    State$A <- A_new
    State
}

#' Global update step for the state covariance matrix V
#'
#' @description
#' Performs the conditional update of the global covariance matrix
#' \code{V} which regulates pooling. Given the group-specific
#' coefficient matrices \code{A_g}, their deviations from the global
#' matrix \code{A}, and the group covariance matrices \code{S_g},
#' the function computes the posterior parameters of an
#' inverse-Wishart distribution and samples a new value for \code{V}.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing \code{W}
#' and \code{eta}.
#' @param State List containing the current state of the sampler,
#' including the global matrix \code{A}, the lists \code{Ag} and \code{Sg},
#' and the current value of \code{V}.
#' @param Hyper List of scalar hyperparameters produced by \code{hyper()},
#' containing in particular \code{w}.
#'
#' @return
#' The \code{State} list updated with a new draw for \code{V}.
#'
#' @details
#' The update follows the inverse-Wishart conditional posterior:
#' \itemize{
#'   \item The sum of quadratic forms
#'   \eqn{\sum_g (A_g - A) S_g^{-1} (A_g - A)^\top}
#'   accumulates group-level deviations.
#'   \item The posterior scale matrix is
#'   \eqn{W_{\post} = w W + \sum_g (A_g - A) S_g^{-1} (A_g - A)^\top}.
#'   \item The posterior degrees of freedom are
#'   \eqn{\eta_{\post} = \eta + G \cdot \text{ncol}(A)}.
#' }
#' All matrices are symmetrized and ridge-stabilized before inversion
#' to ensure numerical positive-definiteness throughout the computation.
#'
#' @examples
#' # Minimal example (requires properly dimensioned objects)
#' # STV <- build_starting_values(N = 5, K = 10, lag = 2)
#' # Hyper <- hyper(STV)
#' # Y_list <- list(matrix(rnorm(50),10,5))
#' # Z_list <- list(matrix(rnorm(100),10,10))
#' # State <- init(STV, Y_list, Z_list, Hyper)
#' # State <- step_V_IW(STV, State, Hyper)
#'
#' @export
step_V_IW <- function(STV, State, Hyper) {
    Ag <- State$Ag
    Sg <- State$Sg
    A  <- State$A

    W   <- STV$W
    eta <- STV$eta

    w <- Hyper$w

    G  <- length(Ag)
    ac <- ncol(A)
    qform_W_sum <- matrix(0, nrow(A), nrow(A))

    for (i in seq_len(G)) {
        Ea   <- Ag[[i]] - A
        Sg_i <- (Sg[[i]] + t(Sg[[i]]))/2
        USg  <-  chol(Sg_i)
        Sg_inv <- chol2inv(USg)
        qform_W_sum <- qform_W_sum + Ea %*% Sg_inv %*% t(Ea)
    }

    W <- (W + t(W))/2
    W_post <- w * W + qform_W_sum
    W_post <- (W_post + t(W_post))/2

    eta_post <- eta + G * ac

    V_new <- invwishart_rnd(eta_post, W_post)
    V_new <- (V_new + t(V_new))/2
    State$V <- V_new
    State
}

#' Global update step for the observation covariance matrix Sigma
#'
#' @description
#' Updates the global observation covariance matrix \code{Sigma}.
#' Given the group-specific covariance matrices
#' \code{S_g} and the hyperparameters stored in \code{STV}, the function
#' constructs the posterior parameters of a Wishart distribution and
#' samples a new value for \code{Sigma}.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing in particular \code{SS},
#' \code{nu}, and \code{mu_Sigma}.
#' @param State List containing the current state of the sampler,
#' including the list \code{Sg} of group-specific covariance matrices,
#' and the current global value \code{Sigma}.
#'
#' @return
#' The updated \code{State} list with a new draw for \code{Sigma}.
#'
#' @details
#' The update computes the inverse-Wishart precision contributions
#' from the group-specific matrices:
#' \itemize{
#'   \item Each \code{S_g} contributes its inverse \code{S_g^{-1}}.
#'   \item These are scaled by \code{nu - N - 1} and summed.
#'   \item The global prior contribution is \code{SS^{-1}} from
#'   \code{STV$SS}.
#' }
#' All matrices are symmetrized and ridge-stabilized before inversion
#' to ensure numerical stability.
#'
#' @examples
#' # Skeleton example (dimensions only)
#' # STV <- build_starting_values(N = 5, K = 10, lag = 2)
#' # Hyper <- hyper(STV)
#' # Y_list <- list(matrix(rnorm(50),10,5))
#' # Z_list <- list(matrix(rnorm(100),10,10))
#' # State <- init(STV, Y_list, Z_list, Hyper)
#' # State <- step_Sigma_W(STV, State)
#'
#' @export
step_Sigma_W <- function(STV, State) {
    Sg       <- State$Sg
    Smat     <- STV$SS
    nu       <- STV$nu
    mu_Sigma <- STV$mu_Sigma

    G  <- length(Sg)
    N  <- nrow(Smat)
    sc <- nu - N - 1

    Sg_inv_sum <- matrix(0, N, N)

    Smat  <- (Smat + t(Smat))/2
    US    <- chol(Smat)
    S_inv <- chol2inv(US)

    for (i in seq_len(G)) {
        Sg_i <- (Sg[[i]] + t(Sg[[i]]))/2
        USg <- chol(Sg_i)
        Sg_inv_sum <- Sg_inv_sum + chol2inv(USg)
    }

    SSg <- S_inv + sc * Sg_inv_sum
    SSg <- (SSg + t(SSg))/2


    USSg <- chol(SSg)
    S_post <- chol2inv(USSg)
    S_post <- (S_post + t(S_post))/2


    mu_Sigma_post <- mu_Sigma + G * nu

    Sigma_new <- wishart_rnd(mu_Sigma_post, S_post)
    Sigma_new <- (Sigma_new + t(Sigma_new))/2
    State$Sigma <- Sigma_new
    State
}

#' Update step for the scalar parameter m
#'
#' @description
#' Updates the global scalar parameter \code{m}.
#' Conditional on the current values of \code{A}, \code{V},
#' \code{M}, and the hyperparameters stored in \code{STV} and \code{Hyper},
#' the function computes the posterior mean and variance of \code{m} and
#' draws a new value from a univariate normal distribution.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing in particular the matrices.
#' \code{M} and \code{S}, and scalars \code{mum} and \code{sigma2m}.
#' @param State List containing the current global state of the sampler.
#' @param Hyper List of scalar hyperparameters produced by \code{hyper()}.
#'
#' @return
#' The updated \code{Hyper} list with a new draw for \code{m}.
#'
#' @details
#' The function computes:
#' \itemize{
#'   \item the posterior precision contribution from the matrix-normal
#'   likelihood, based on the matrices \code{M}, \code{S}, and \code{V};
#'   \item the posterior variance \code{var_post};
#'   \item the posterior mean \code{mu_post};
#'   \item a new value \code{m_new \~ N(mu_post, var_post)}.
#' }
#'
#' Every covariance-related matrix is symmetrized and ridge-stabilized
#' to ensure numerical positive-definiteness. Cholesky factorizations
#' are used systematically for robustness.
#'
#' @examples
#' # Minimal reproducible structure (dimensions only)
#' # STV <- build_starting_values(N = 5, K = 10, lag = 2)
#' # Hyper <- hyper(STV)
#' # Y_list <- list(matrix(rnorm(50),10,5))
#' # Z_list <- list(matrix(rnorm(100),10,10))
#' # State <- init(STV, Y_list, Z_list, Hyper)
#' # Hyper <- step_m_N(STV, State, Hyper)
#'
#' @export
step_m_N <- function(STV, State, Hyper) {

    V    <- State$V
    A    <- State$A
    Smat <- STV$S
    M    <- STV$M

    s        <- Hyper$s
    mu       <- STV$mum
    sigma2m  <- STV$sigma2m

    V    <- (V + t(V)) / 2
    Smat <- (Smat + t(Smat)) / 2

    UV <- chol(V + diag(1e-8, nrow(V)))

    Y <- backsolve(UV, M, transpose = TRUE)
    X <- backsolve(UV, Y, transpose = FALSE)
    Q <- t(M) %*% X

    US0 <- chol(Smat)

    W  <- backsolve(US0, Q, transpose = TRUE)
    Z  <- backsolve(US0, W, transpose = FALSE)
    tz <- sum(diag(Z))

    var_post <- 1 / ((1 / sigma2m) + (1 / s) * tz)

    MVA  <- t(X) %*% A
    W2   <- backsolve(US0, MVA, transpose = TRUE)
    SMVA <- backsolve(US0, W2,  transpose = FALSE)
    ts   <- sum(diag(SMVA))

    mu_post <- var_post * ((mu / sigma2m) + (1 / s) * ts)

    m_new <- rnorm(1, mean = mu_post, sd = sqrt(var_post))
    Hyper$m <- m_new
    return(Hyper)
}

#' Update step for the scalar s
#'
#' @description
#' Updates scalar parameter \code{s} appearing
#' in the hierarchical prior for the matrix-normal distribution for A.
#' Conditional on the current matrices \code{A}, \code{V}, \code{M}
#' and the hyperparameters in \code{STV}, the function computes the
#' inverse-gamma posterior parameters and draws a new value for \code{s}.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing \code{M}, \code{S},
#' \code{ss}, and \code{nus}.
#' @param State List with the current sampler state, containing in
#' particular \code{A} and \code{V}.
#' @param Hyper List of current hyperparameters, containing
#' \code{m} and \code{s}.
#'
#' @return
#' The updated \code{Hyper} list with a new draw for \code{s}.
#'
#' All matrices involved are symmetrized and ridge-adjusted before
#' inversion for numerical stability.
#'
#' @examples
#' # STV <- build_starting_values(N=5, K=10, lag=2)
#' # Hyper <- hyper(STV)
#' # State <- init(STV, list(matrix(rnorm(50),10,5)),
#' #                    list(matrix(rnorm(100),10,10)), Hyper)
#' # Hyper <- step_s_IG(STV, State, Hyper)
#'
#' @export
step_s_IG <- function(STV, State, Hyper) {

    A    <- State$A
    V    <- State$V
    Smat <- STV$S
    M    <- STV$M

    m   <- Hyper$m
    ss  <- STV$ss
    nus <- STV$nus

    V    <- (V + t(V)) / 2
    Smat <- (Smat + t(Smat)) / 2

    K <- nrow(A); N <- ncol(A)
    D <- A - m * M

    UV<- chol(V + diag(1e-8, nrow(V)))
    Y <- backsolve(UV, D, transpose = TRUE)
    X <- backsolve(UV, Y, transpose = FALSE)

    Q <- t(D) %*% X

    US0 <- chol(Smat)
    W <- backsolve(US0, Q, transpose = TRUE)
    Z <- backsolve(US0, W, transpose = FALSE)

    tval   <- sum(diag(Z))
    b_post <- nus + 0.5 * tval
    a_post <- ss  + (K * N) / 2

    s_new <- 1 / rgamma(1, shape = a_post, rate = b_post)

    Hyper$s <- s_new
    return(Hyper)
}

#' Update step for the scalar s_Sigma
#'
#' @description
#' Updates the scalar hyperparameter \code{s_Sigma} that controls the
#' scale of the global covariance matrix \code{Sigma}. The update uses
#' an inverse-gamma posterior derived from the Wishart prior structure
#' on \code{Sigma}.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing \code{SS}, \code{mu_Sigma},
#' \code{as}, and \code{bs}.
#' @param State List containing the current sampler state, in particular
#' the global covariance matrix \code{Sigma}.
#' @param Hyper List of hyperparameters, containing at least
#' \code{s_Sigma}.
#'
#' @return
#' The updated \code{Hyper} list with a new draw for \code{s_Sigma}.
#'
#' A new value is drawn as
#' \deqn{s_{\Sigma} \sim \mathrm{IG}(a_{\post}, b_{\post}).}
#'
#' All matrices are symmetrized and stabilized by Cholesky factorizations
#' before inversion.
#'
#' @examples
#' # STV <- build_starting_values(N=5, K=10, lag=2)
#' # Hyper <- hyper(STV)
#' # State <- init(STV, list(matrix(rnorm(50),10,5)),
#' #                    list(matrix(rnorm(100),10,10)), Hyper)
#' # Hyper <- step_s_Sigma_IG(STV, State, Hyper)
#'
#' @export
step_s_Sigma_IG <- function(STV, State, Hyper) {

    Sigma    <- State$Sigma
    SS       <- STV$SS
    mu_Sigma <- STV$mu_Sigma
    as       <- STV$as
    bs       <- STV$bs

    Sigma <- (Sigma + t(Sigma)) / 2
    SS    <- (SS    + t(SS))    / 2

    N <- nrow(Sigma)

    USS <- chol(SS)

    W_left  <- backsolve(USS, Sigma, transpose = TRUE)
    W_full  <- backsolve(USS, W_left, transpose = FALSE)
    tr_val  <- sum(diag(W_full))

    as_post <- as + (mu_Sigma * N) / 2
    bs_post <- bs + 0.5 * tr_val

    s_Sigma_new <- 1 / rgamma(1, shape = as_post, rate = bs_post)

    Hyper$s_Sigma <- s_Sigma_new
    return(Hyper)
}

#' Update step for the scalar w
#'
#' @description
#' Updates the global scalar hyperparameter \code{w} associated with the
#' Wishart prior on the covariance matrix \code{V}. Conditional on
#' the current value of \code{V} and the scale matrix \code{W} from
#' \code{STV}, the function computes the Gamma posterior parameters and
#' draws a new value of \code{w}.
#'
#' @param STV List of starting values and hyperparameters generated by
#' \code{build_starting_values()}, containing \code{W},
#' \code{eta}, \code{sw}, and \code{aw}.
#' @param State Current sampler state, containing at least the matrix
#' \code{V}.
#' @param Hyper List of hyperparameters, containing the current value of
#' \code{w}.
#'
#' @return
#' The updated \code{Hyper} list with a new sample of \code{w}.
#'
#' A new value is drawn as
#' \deqn{w \sim \mathrm{Gamma}(a_{\post},\ \text{scale}=b_{\post}).}
#'
#' All matrices (\code{V}, \code{W}) are symmetrized and ridge-stabilized
#' prior to Cholesky inversion.
#'
#' @examples
#' # STV <- build_starting_values(N=5, K=10, lag=2)
#' # Hyper <- hyper(STV)
#' # Y_list <- list(matrix(rnorm(50),10,5))
#' # Z_list <- list(matrix(rnorm(100),10,10))
#' # State <- init(STV, Y_list, Z_list, Hyper)
#' # Hyper <- step_w_G(STV, State, Hyper)
#'
#' @export
step_w_G <- function(STV, State, Hyper) {

    V   <- State$V
    W   <- STV$W
    eta <- STV$eta

    sw <- STV$sw
    aw <- STV$aw

    V <- (V + t(V)) / 2
    W <- (W + t(W)) / 2

    K <- nrow(V)

    UV   <- chol(V + diag(1e-8, nrow(V)))
    Vinv <- chol2inv(UV)

    bw_post <- 1 / ((1 / aw) + 0.5 * sum(diag(W %*% Vinv)))
    aw_post <- sw + 0.5 * (eta * K)

    w_new <- rgamma(1, shape = aw_post, scale = bw_post)

    Hyper$w <- w_new
    return(Hyper)
}

#' Update all scalar hyperparameters
#'
#' @description
#' Sequentially updates all scalar hyperparameters of the hierarchical
#' VAR model. This function applies the four individual hyperparameter
#' update steps:
#' \code{step_m_N()}, \code{step_s_IG()},
#' \code{step_w_G()}, and \code{step_s_Sigma_IG()}.
#'
#' @param STV List of starting values and structural hyperparameters
#' generated by \code{build_starting_values()}.
#' @param State Current sampler state, containing matrices
#' \code{A}, \code{V}, \code{Sigma}, and the lists \code{Ag}, \code{Sg}.
#' @param Hyper List of scalar hyperparameters to update.
#'
#' @return
#' The updated \code{Hyper} list after applying all four hyperparameter
#' update steps.
#'
#' @details
#' This function is a wrapper that applies:
#' \itemize{
#'   \item \code{step_m_N()} — update of the global location parameter \code{m};
#'   \item \code{step_s_IG()} — update of the variance-like scale \code{s};
#'   \item \code{step_w_G()} — update of the Wishart scale multiplier \code{w};
#'   \item \code{step_s_Sigma_IG()} — update of the scale parameter
#'         controlling \code{Sigma}.
#' }
#'
#' @examples
#' # STV <- build_starting_values(N=5, K=10, lag=2)
#' # Hyper <- hyper(STV)
#' # Y_list <- list(matrix(rnorm(50),10,5))
#' # Z_list <- list(matrix(rnorm(100),10,10))
#' # State <- init(STV, Y_list, Z_list, Hyper)
#' # Hyper <- step_hyper_all(STV, State, Hyper)
#'
#' @export
step_hyper_all <- function(STV, State, Hyper) {
    Hyper <- step_m_N(STV, State, Hyper)
    Hyper <- step_s_IG(STV, State, Hyper)
    Hyper <- step_w_G(STV, State, Hyper)
    Hyper <- step_s_Sigma_IG(STV, State, Hyper)
    return(Hyper)
}
